/*
 * See http://www.itk.org/Wiki/ITK/Examples/DICOM/ResampleDICOM
 * http://sourceforge.net/apps/mediawiki/gdcm/index.php?title=Writing_DICOM
 */


#include "itkImage.h"
#include "itkImageFileReader.h"
#include "itkGDCMImageIO.h"
#include "itkNumericSeriesFileNames.h"
#include "itkImageSeriesWriter.h"
#include "itkMetaDataObject.h"
#include <itksys/SystemTools.hxx>

#include "gdcmUIDGenerator.h"

int main( int argc, char * argv[] )
{
  if( argc < 5 )
    {
    std::cerr << "Usage: " << std::endl;
    std::cerr << argv[0] << "  inputImageFile OutputDicomDirectory patient_id rec_kernel" << std::endl;
    return EXIT_FAILURE;
    }


  typedef signed short    PixelType;
  const unsigned int      Dimension = 3;

  typedef itk::Image< PixelType, Dimension >      ImageType;
  typedef itk::ImageFileReader< ImageType >       ReaderType;

  ReaderType::Pointer reader = ReaderType::New();

  reader->SetFileName( argv[1] );

  try
    {
    reader->Update();
    }
  catch (itk::ExceptionObject &excp)
    {
    std::cerr << "Exception thrown while reading the image" << std::endl;
    std::cerr << excp << std::endl;
    return EXIT_FAILURE;
    }

  typedef itk::GDCMImageIO                        ImageIOType;
  typedef itk::NumericSeriesFileNames             NamesGeneratorType;

  ImageIOType::Pointer gdcmIO = ImageIOType::New();

  const char * outputDirectory = argv[2];

  itksys::SystemTools::MakeDirectory( outputDirectory );

  typedef signed short    OutputPixelType;
  const unsigned int      OutputDimension = 2;

  typedef itk::Image< OutputPixelType, OutputDimension >    Image2DType;

  typedef itk::ImageSeriesWriter<
                         ImageType, Image2DType >  SeriesWriterType;

  NamesGeneratorType::Pointer namesGenerator = NamesGeneratorType::New();
  itk::MetaDataDictionary & dict = gdcmIO->GetMetaDataDictionary();

  /*
   * As we are creating a new DICOM image we also need to create
   * new UID for study, serie and sop
   */

  /*
   * Automatically generated by the SeriesWriter:
  gdcm::UIDGenerator study_uid;
  std::string studyUID = study_uid.Generate();
  itk::EncapsulateMetaData<std::string>(dict,"0020|000d", studyUID);
  gdcm::UIDGenerator serie_uid;
  std::string seriesUID = serie_uid.Generate();
  itk::EncapsulateMetaData<std::string>(dict,"0020|000e", seriesUID);
  */
  gdcm::UIDGenerator frame_uid;
  std::string frameOfReferenceUID = frame_uid.Generate();
  itk::EncapsulateMetaData<std::string>(dict,"0020|0052", frameOfReferenceUID);

  // Image Number
   // Va settato con un dizionario diverso x ogni slice! itk::EncapsulateMetaData<std::string>(*dict,"0020|0013", value.str());


  std::string value;
  value = "CT";
  itk::EncapsulateMetaData<std::string>(dict, "0008|0060", value ); // Modality
  value = "DERIVED\\SECONDARY";
  itk::EncapsulateMetaData<std::string>(dict, "0008|0008", value); // Image Type
  value = "WST"; // Workstation
  itk::EncapsulateMetaData<std::string>(dict, "0008|0064", value); // Conversion Type
  value = argv[3]; // Let user specify it
  itk::EncapsulateMetaData<std::string>(dict, "0010|0020", value); // Patient ID
  value = argv[4]; // Let user specify it
  itk::EncapsulateMetaData<std::string>(dict, "0018|1210", value);  // Reconstruction Kernel

  std::ostringstream ss;
  ss << reader->GetOutput()->GetSpacing()[2]; // Calculate from image spacing along z
  itk::EncapsulateMetaData<std::string>(dict, "0018|0050", ss.str());  // Slice Thickness
  itk::EncapsulateMetaData<std::string>(dict,"0018|0088", ss.str());  // Spacing Between Slices



  SeriesWriterType::Pointer seriesWriter = SeriesWriterType::New();

  seriesWriter->SetInput( reader->GetOutput() );
  seriesWriter->SetImageIO( gdcmIO );


  ImageType::RegionType region =
     reader->GetOutput()->GetLargestPossibleRegion();

  ImageType::IndexType start = region.GetIndex();
  ImageType::SizeType  size  = region.GetSize();


  std::string format = outputDirectory;

  format += "/image%03d.dcm";

  namesGenerator->SetSeriesFormat( format.c_str() );

  namesGenerator->SetStartIndex( start[2] );
  namesGenerator->SetEndIndex( start[2] + size[2] - 1 );
  namesGenerator->SetIncrementIndex( 1 );


  seriesWriter->SetFileNames( namesGenerator->GetFileNames() );


  try
    {
    seriesWriter->Update();
    }
  catch( itk::ExceptionObject & excp )
    {
    std::cerr << "Exception thrown while writing the series " << std::endl;
    std::cerr << excp << std::endl;
    return EXIT_FAILURE;
    }


  return EXIT_SUCCESS;


}

